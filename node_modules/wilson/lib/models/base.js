var fields = require('wilson/models/fields'),
    managers = require('wilson/models/managers');

var MODEL_META_KEY = 'Meta',
    FIELD_DELIM = '__';

var isFieldGenerator = function(item) {
    return item instanceof Function && item[fields.FIELD_GENERATOR_KEY];
};

var ModelPrototype = function(options) {
    Object.keys(options).forEach(function(key) {
        this[key] = options[key];
    }, this); 
};

ModelPrototype.prototype._processData = function(data) {
    var meta = this.constructor._meta;
    meta.fields.forEach(function(field) {
        this[field.name] = field.getJSValue(this, data[field.getColumn()]);
    }, this);
};

var ModelMeta = function(model, fields, options) {
    this.model = model;
    this.fields = fields;
    this.columns = columns;
    this.fieldsByName = {};

    fields.forEach(function(field) {
        field.contribToClass(model.prototype);
        var column = field.getColumn();
        if(this.columns.indexOf(column) === -1) {
            this.columns.push(column);
        }
        this.fieldsByName[field.name] = field; 
    }, this);

    Object.keys(options).forEach(function(key) {
        this[key] = options[key];
    }, this);
};

ModelMeta.prototype.getFieldByName = function(name) {
    return this.fieldsByName[name];
};

var Model = function(opts) {
    this.opts = opts;
    this.resolvers = [];
    this.reverseRelations = {};
};

Model.prototype.addReverseRelation = function(from_field) {
    var managerClass = managers.Manager.subclass({
            getQuerySet:function() {
                var filter = {};
                filter[from_field.name] = this.instance[from_field.rel.to_field.name];
                return from_field.model.objects.filter(filter);
            },
            setInstance:function(instance) {
                this.instance = instance;
            }
        });
    self.reverseRelations[from_field.related_name] = new managerClass;
};

Model.prototype.addResolver = function(local, callback) {
    this.resolvers.push([local, callback]);
};

Model.addManagers = function(model, managers) {
    managers._default_manager = new managers.Manager();
    if(!managers.objects) {
        managers.objects = managers._default_manager;
    }
    Object.keys(managers).forEach(function(key) {
        model[key] = managers[key];
        model[key].contribToClass(model);
    });
    return model;
};

Model.prototype.compile = function(app_instance, model_name) {
    var self = this,
        getCompiledModel = function() {
            return function(data) {
                var callee = arguments.callee;

                this.model = self;
                this.app_instance = app_instance;
                this.model_name = model_name;
                this._processData(data);

                // and populate reverse relations
                Object.keys(self.reverseRelations).forEach(function(key) {
                    this[key] = self.reverseRelations[key];
                    this[key].contribToClass(callee);           
                    this[key].setInstance(this);           
                }, this);
            };
        };

    var fields = [],
        attrs = {},
        meta = {},
        managers = {},
        CompiledModel = getCompiledModel(),
        hasAuto = false,
        options = this.opts,
        objects = new managers.Manager(CompiledModel);

    Object.keys(options).forEach(function(key) {
        if(isFieldGenerator(options[key])) {
            var fieldInstance = options[key](CompiledModel, key);
            hasAuto = fieldInstance.isPrimary ? key : false;
            fields.push(fieldInstance);
        } else if(key === MODEL_META_KEY) {
            meta = options[key];
        } else if(options[key] instanceof managers.Manager) {
            managers[key] = options[key];            
        } else {
            attrs[key] = options[key];
        }
    });

    Model.addManagers(CompiledModel, managers);

    if(!hasAuto) {
        fields.push(fields.AutoField()(CompiledModel, 'id'));
        hasAuto = 'id';
    }
    fields.push(fields.AliasField({alias:hasAuto})(CompiledModel, 'pk'));

    CompiledModel.prototype = new ModelPrototype(attrs);
    CompiledModel._meta = new ModelMeta(fields, meta); 
    CompiledModel.prototype.constructor = CompiledModel;

    // once we've resolved the model once, change the addResolver function
    // so that it immediately resolves.
    this.addResolver = function(local, resolver) {
        var local = local_and_resolver[0],
            resolver = local_and_resolver[1];
        if(!local) {
            var ResolvedModel = getCompiledModel();
            Model.addManagers(ResolvedModel, managers);
            ResolvedModel.prototype = new ModelPrototype(attrs);
            ResolvedModel._meta = new ModelMeta(fields, meta);
            ResolvedModel.prototype.constructor = ResolvedModel;
            resolver(ResolvedModel);
        } else {
            resolver(CompiledModel);
        }
    };

    this.resolvers.forEach(function(local_and_resolver) {
        this.addResolver.apply(this, local_and_resolver);
    }, this);

    return CompiledModel;
};

exports.model = function(options) {
    return new Model(options);
};
exports.Model = Model;

Object.keys(fields).forEach(function(key) {
    exports[key] = fields[key];
});

